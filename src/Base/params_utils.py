import cog

def declare_begin(module):
    class_name = module.ClassName
    namespace = module.NameSpace
    params = module.Params
    param_path = module.ParamPath
    class_doc = module.ClassDoc

    cog.out(f'''
#include <Base/Parameter.h>

namespace {namespace} {{
/** {class_doc}

* The parameters are under group "{param_path}"
*
* This class is auto generated by {class_name}.py. Modify that file
* instead of this one, if you want to add any parameter. You need
* to install Cog Python package for code generation:
* @code
*     pip install cogapp
* @endcode
*
* Once modified, you can regenerate the header and the source file,
* @code
*     python3 -m cogapp -r {class_name}.h {class_name}.cpp'
* @endcode
*
* You can add a new parameter by adding lines in {class_name}.py. Available
* parameter types are 'Int, UInt, String, Bool, Float'. For example, to add
* a new Int type parameter,
* @code
*     ParamInt(parameter_name, default_value, documentation, on_change=False)
* @endcode
*
* If there is special handling on parameter change, pass in on_change=True.
* And you need to provide a function implementation in {class_name}.cpp with
* the following signature.
 * @code
 *     void {class_name}:on<parameter_name>Changed()
 * @endcode
 */
class {namespace}Export {class_name} {{
public:
    static ParameterGrp::handle getHandle();
''')

    for param in params:
        cog.out(f'''
    static const {param.C_Type} & {param.name}();
    static const {param.C_Type} & default{param.name}();
    static void remove{param.name}();
    static void set{param.name}(const {param.C_Type} &v);
    static const char *doc{param.name}();
''')
        if param.on_change:
            cog.out(f'''
    static void on{param.name}Changed();
''')


def declare_end(module):
    namespace = module.NameSpace
    cog.out('''
};

} // namespace {namespace}
''')


def define(module):
    class_name = module.ClassName
    namespace = module.NameSpace
    params = module.Params
    param_path = module.ParamPath
    class_doc = module.ClassDoc

    cog.out(f'''
#include <unordered_map>
#include <App/Application.h>
#include <App/DynamicProperty.h>
#include "{class_name}.h"

using namespace {namespace};

class {class_name}P: public ParameterGrp::ObserverType {{
public:
    ParameterGrp::handle handle;
    std::unordered_map<const char *,void(*)({class_name}P*),App::CStringHasher,App::CStringHasher> funcs;
''')

    for param in params:
        cog.out(f'''
    {param.C_Type} {param.name};''')

    cog.out(f'''

    {class_name}P() {{
        handle = App::GetApplication().GetParameterGroupByPath("{param_path}");
        handle->Attach(this);
''')

    for param in params:
        cog.out(f'''
        {param.name} = handle->Get{param.Type}("{param.name}", {param.default});
        funcs["{param.name}"] = &{class_name}P::update{param.name};''')

    cog.out(f'''
    }}

    ~{class_name}P() {{
    }}

    void OnChange(Base::Subject<const char*> &, const char* sReason) {{
        if(!sReason)
            return;
        auto it = funcs.find(sReason);
        if(it == funcs.end())
            return;
        it->second(this);
    }}

''')

    for param in params:
        if not param.on_change:
            cog.out(f'''
    static void update{param.name}({class_name}P *self) {{
        self->{param.name} = self->handle->Get{param.Type}("{param.name}", {param.default});
    }}''')
        else:
            cog.out(f'''
    static void update{param.name}({class_name}P *self) {{
        auto v = self->handle->Get{param.Type}("{param.name}", {param.default});
        if (self->{param.name} != v) {{
            self->{param.name} = v;
            {class_name}::on{param.name}Changed();
        }}
    }}''')

    cog.out(f'''
}};

{class_name}P *instance() {{
    static {class_name}P *inst;
    if (!inst)
        inst = new {class_name}P;
    return inst;
}}

ParameterGrp::handle {class_name}::getHandle() {{
    return instance()->handle;
}}
''')

    for param in params:
        cog.out(f'''
const char *{class_name}::doc{param.name}() {{
    return {param.doc(class_name)};
}}
const {param.C_Type} & {class_name}::{param.name}() {{
    return instance()->{param.name};
}}
const {param.C_Type} & {class_name}::default{param.name}() {{
    const static {param.C_Type} def = {param.default};
    return def;
}}
void {class_name}::set{param.name}(const {param.C_Type} &v) {{
    instance()->handle->Set{param.Type}("{param.name}",v);
    instance()->{param.name} = v;
}}
void {class_name}::remove{param.name}() {{
    instance()->handle->Remove{param.Type}("{param.name}");
}}
''')

class Param:
    def __init__(self, name, default, doc='', on_change=False):
        self.name = name
        self._default = default
        self._doc = doc
        self.on_change = on_change

    @property
    def default(self):
        return self._default

    def doc(self, class_name):
        if not self._doc:
            return '""'
        return f'QT_TRANSLATE_NOOP("{class_name}", "{self._doc}")'

class ParamBool(Param):
    Type = 'Bool'
    C_Type = 'bool'

    @property
    def default(self):
        if isinstance(self._default, str):
            return self._default
        return 'true' if self._default else 'false'

class ParamFloat(Param):
    Type = 'Float'
    C_Type = 'double'

class ParamString(Param):
    Type = 'ASCII'
    C_Type = 'std::string'

    @property
    def default(self):
        return f'"{self._default}"'

class ParamInt(Param):
    Type = 'Int'
    C_Type = 'long'

class ParamUInt(Param):
    Type = 'Unsigned'
    C_Type = 'unsigned long'

